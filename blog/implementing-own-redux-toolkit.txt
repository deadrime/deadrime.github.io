4:I[5613,[],""]
5:I[1778,[],""]
6:I[1769,["174","static/chunks/174-8e9eed3881b7809b.js","956","static/chunks/956-58e65a7b18ba4fa9.js","185","static/chunks/app/layout-cfc708733364b1d9.js"],"ThemeProvider"]
7:I[5250,["911","static/chunks/d2af3f89-c53dca3c0dccae07.js","174","static/chunks/174-8e9eed3881b7809b.js","568","static/chunks/568-50733f35e6378467.js","581","static/chunks/581-1d9dfcac47f514ec.js","206","static/chunks/app/blog/%5Bslug%5D/layout-5dd5a28269546c6a.js"],""]
8:I[5630,["174","static/chunks/174-8e9eed3881b7809b.js","956","static/chunks/956-58e65a7b18ba4fa9.js","185","static/chunks/app/layout-cfc708733364b1d9.js"],""]
0:["JTbi38zB_2REzZ6OvM7Nt",[[["",{"children":["blog",{"children":[["slug","implementing-own-redux-toolkit","d"],{"children":["__PAGE__?{\"slug\":\"implementing-own-redux-toolkit\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["slug","implementing-own-redux-toolkit","d"],{"children":["__PAGE__",{},["$L1","$L2",null]]},[null,"$L3",null]]},["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/8166fd224e101e31.css","precedence":"next","crossOrigin":""}]]}]]},[null,["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__variable_baa796 __variable_ff450d __variable_f72f74 min-h-screen flex flex-col gap-4","children":[["$","script",null,{"id":"theme-hydration","dangerouslySetInnerHTML":{"__html":"\n!function() {\n  const preferredDarkModeBySystem = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n  const savedTheme = localStorage.getItem(\"selectedTheme\");\n  const theme =  savedTheme ? savedTheme : preferredDarkModeBySystem ? 'dark' : 'light';\n  document.documentElement.setAttribute('data-theme', theme);\n}();\n"}}],["$","$L6",null,{"children":[["$","header",null,{"style":{"maxWidth":1180},"className":"w-full mx-auto px-3 md:px-8 py-4 flex items-center","children":[["$","$L7",null,{"href":"/","className":"font-code text-md","children":["<","Zhenya",">"]}],["$","$L8",null,{"className":"ml-auto"}]]}],["$","main",null,{"style":{"maxWidth":1180},"className":"w-full mx-auto px-3 md:px-8 py-4","children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}],["$","footer",null,{"style":{"maxWidth":1180},"className":"w-full mx-auto px-3 md:px-8 py-4 mt-auto","children":["$","$L7",null,{"href":"/","className":"font-code text-md","children":["</","Zhenya",">"]}]}]]}]]}]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/863710d6b18a0d81.css","precedence":"next","crossOrigin":""}]],"$L9"]]]]
a:I[1202,["911","static/chunks/d2af3f89-c53dca3c0dccae07.js","174","static/chunks/174-8e9eed3881b7809b.js","568","static/chunks/568-50733f35e6378467.js","581","static/chunks/581-1d9dfcac47f514ec.js","206","static/chunks/app/blog/%5Bslug%5D/layout-5dd5a28269546c6a.js"],""]
d:I[1749,["911","static/chunks/d2af3f89-c53dca3c0dccae07.js","174","static/chunks/174-8e9eed3881b7809b.js","568","static/chunks/568-50733f35e6378467.js","581","static/chunks/581-1d9dfcac47f514ec.js","206","static/chunks/app/blog/%5Bslug%5D/layout-5dd5a28269546c6a.js"],"Image"]
11:I[877,["911","static/chunks/d2af3f89-c53dca3c0dccae07.js","174","static/chunks/174-8e9eed3881b7809b.js","568","static/chunks/568-50733f35e6378467.js","581","static/chunks/581-1d9dfcac47f514ec.js","206","static/chunks/app/blog/%5Bslug%5D/layout-5dd5a28269546c6a.js"],"TableOfContent"]
b:T50e,
type User = {
  id: string;
  username: string;
  displayName: string;
}

export const usersSlice = createSlice({
  name: 'users',
  defaultState: {
    userById: {} as Record<string, User>,
    usernameById: {} as Record<string, string>,
  },
  actions: {
    addUser: (state, user: User) => {
      // state должен иметь тот же тип, что и defaultState
      state.userById[user.id] = user;
      state.usernameById[user.username] = user.id;
    },
    deleteUser: (state, userId: string) => {
      const user = state.userById[userId];
      delete state.usernameById[user.username];
      delete state.userById[userId];
    }
  },
  selectors: {
    selectUserByUsername: (state, username: string) => state.userById[state.usernameById[username]],
  }
});

usersSlice.actions// экшены
usersSlice.selectors// селекторы

// ...

// SomeComponent.tsx

// user Должен иметь тип User
const user = useSelector(state => state.selectUserByUsername(state.users, 'someUsername'));

const addUser = useCallback(() => {
  dispatch(
    // Аргументом addUser должен быть объект User
    usersSlice.actions.addUser({
      id: '2',
      username: 'username2',
      displayName: 'some display name',
    })
  )
}, [dispatch])
c:T64b,type Scoped<String extends string, Scope extends string> = `${Scope}/${String}`;

export const createSlice = <
  Name extends string,
  State extends Record<string, unknown>,
  Actions extends Record<string, SliceActionCreator<State>>,
  ActionKey extends Extract<keyof Actions, string>,
  ScopedActionType extends Scoped<ActionKey, Name>,
  ActionPayload extends Parameters<Actions[ActionKey]>[1],
  Action extends { type: ScopedActionType, payload: ActionPayload },
>({
  name,
  actions,
  defaultState,
  selectors,
}: CreateSliceProps<Name, State, Actions, Selectors>) => {
  const actionKeys = Object.keys(actions) as ActionKey[];
  const actionTypeByActionKey = actionKeys.reduce((acc, action) => {
    const scopedActionType = `${name}/${action}` as ScopedActionType;
    acc[scopedActionType] = action;
    return acc;
  }, {} as Record<ScopedActionType, ActionKey>)

  const reducer = (state: State = defaultState, action: Action) => {
    const nextState = produce(state, draft => {
      const actionType = actionTypeByActionKey[action.type]
      actions[actionType]?.(draft as State, action.payload);
    })
    return nextState;
  }

  const sliceActions = actionKeys.reduce((acc, curr) => {
    acc[curr] = (payload) => {
      const scopedActionType = `${name}/${curr}` as ScopedActionType;

      return {
        type: scopedActionType,
        payload,
      }
    }
    return acc;
  }, {} as {
    [ActionKey in Extract<keyof Actions, string>]: (payload: Parameters<Actions[ActionKey]>[1]) => { type: Scoped<ActionKey, Name>, payload: P }
  })

  return {
    actions: sliceActions,
  }
}
e:T433,import type { Reducer } from 'redux';

type SliceAction<Type extends string = string, Payload = unknown> = {
  type: Type,
  payload: Payload,
}

type SimpleSlice<Name extends string, ReducerType extends Reducer<any, any>> = {
  name: Name;
  reducer: ReducerType,
}

type TypesFromSlices<T> = T extends readonly { name: infer Name extends string, reducer: Reducer<infer State, infer Action> }[]
  ? Action extends SliceAction<infer Type, infer Payload>
  ? {
    action: SliceAction<Type, Payload>,
    state: { [P in Name]: State }
  } : never : never

export const configureStore = <
  Slice extends SimpleSlice<string, Reducer<any, any, any>>,
  State extends TypesFromSlices<Slice[]>['state'],
  Action extends TypesFromSlices<Slice[]>['action'],
>(slices: Slice[]) => {
  const reducersByName = slices.reduce((acc, current) => {
    acc[current.name] = current.reducer;
    return acc;
  }, {} as Record<string, Reducer>);

  const reducer = combineReducers(reducersByName) as Reducer<State, Action>;

  const store = createStore(reducer);

  return {
    store,
  }
}
f:Tf21,
import { createStore, combineReducers } from 'redux'
import type { Store as ReduxStore, Reducer } from 'redux'
import { produce } from 'immer';
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector';

type SliceActionCreator<State, Payload = any> = (state: State, payload: Payload) => void

type SliceSelector<State, Payload = any> = (state: State, payload: Payload) => void

type Scoped<String extends string, Scope extends string> = `${Scope}/${String}`;

type CreateSliceProps<
  Name extends string,
  State extends Record<string, unknown>,
  Actions extends Record<string, SliceActionCreator<State>>,
  Selectors extends Record<string, SliceSelector<State>>
> = {
  name: Name
  actions: Actions
  defaultState: State
  selectors: Selectors
}

export const createSlice = <
  Name extends string,
  State extends Record<string, unknown>,
  Actions extends Record<string, SliceActionCreator<State>>,
  ActionKey extends Extract<keyof Actions, string>,
  ScopedActionType extends Scoped<ActionKey, Name>,
  Selectors extends Record<string, SliceSelector<State>>,
  ActionPayload extends Parameters<Actions[ActionKey]>[1],
  Action extends { type: ScopedActionType, payload: ActionPayload },
>({
  name,
  actions,
  defaultState,
  selectors,
}: CreateSliceProps<Name, State, Actions, Selectors>) => {
  const actionKeys = Object.keys(actions) as ActionKey[];
  const actionTypeByActionKey = actionKeys.reduce((acc, action) => {
    const scopedActionType = `${name}/${action}` as ScopedActionType;
    acc[scopedActionType] = action;
    return acc;
  }, {} as Record<ScopedActionType, ActionKey>)

  const reducer = (state: State = defaultState, action: Action) => {
    const nextState = produce(state, draft => {
      const actionType = actionTypeByActionKey[action.type]
      actions[actionType]?.(draft as State, action.payload);
    })
    return nextState;
  }

  const sliceActions = actionKeys.reduce((acc, curr) => {
    acc[curr] = (payload) => {
      const scopedActionType = `${name}/${curr}` as ScopedActionType;

      return {
        type: scopedActionType,
        payload,
      }
    }
    return acc;
  }, {} as {
    [ActionKey in Extract<keyof Actions, string>]: <P extends Parameters<Actions[ActionKey]>[1]>(payload: P) => { type: Scoped<ActionKey, Name>, payload: P }
  })

  return {
    name,
    reducer,
    actions: sliceActions,
    selectors: selectors,
  }
}

type SliceAction<Type extends string = string, Payload = unknown> = {
  type: Type,
  payload: Payload,
}

type SimpleSlice<Name extends string, ReducerType extends Reducer<any, any>> = {
  name: Name;
  reducer: ReducerType,
}

type TypesFromSlices<T> = T extends { name: infer Name extends string, reducer: Reducer<infer State, infer Action> }[]
  ? Action extends SliceAction<infer Type, infer Payload>
  ? {
    action: SliceAction<Type, Payload>,
    state: { [P in Name]: State }
  } : never : never

export const configureStore = <
  Slice extends SimpleSlice<string, Reducer<any, any, any>>,
  State extends TypesFromSlices<Slice[]>['state'],
  Action extends TypesFromSlices<Slice[]>['action'],
>(slices: Slice[]) => {
  const reducersByName = slices.reduce((acc, current) => {
    acc[current.name] = current.reducer;
    return acc;
  }, {} as Record<string, Reducer>);

  const reducer = combineReducers(reducersByName) as Reducer<State, Action>;

  const store = createStore(reducer);

  return {
    store,
  }
}

export const createUseSelector = <
  Store extends ReduxStore,
  State extends ReturnType<Store['getState']>,
>(store: Store) => {
  const useSelector = <Selector extends (state: State) => unknown>(selector: Selector) => {
    return useSyncExternalStoreWithSelector(
      store.subscribe,
      store.getState,
      store.getState,
      selector
    ) as ReturnType<Selector>;
  }

  return useSelector;
}

2:[["$","div",null,{"className":"flex min-h-screen flex-col justify-between","children":["\n","\n",["$","h2",null,{"id":"motivation","children":"Мотивация"}],"\n",["$","p",null,{"children":["Как правило мы задумываемся о глобальном стейте, когда приложение обрастает какой-то сложной бизнес логикой и прокидывать пропсы становится больно.\nВ случае с более менее легкой бизнес логикой можно обойтись ",["$","code",null,{"className":"$undefined","children":"React Context"}],". Но когда уже не хватает и его - на помощь приходит стейт менеджер,\nнапример редакс. Обычно в качестве примера использования редакса показывают TODO лист, что на мой взгляд тупо - мне трудно представить\nсебе туду лист, который был бы достаточно сложен, что для него бы мог потребоваться глобальный стейт.\nСкорее вы будете хранить в стейте профиль авторизованного юзера или какие-то сложные структуры,\nкоторые нужно уметь находить разными способами, скажем ",["$","code",null,{"className":"$undefined","children":"profileById"}],", ",["$","code",null,{"className":"$undefined","children":"profileByUsername"}]," или ",["$","code",null,{"className":"$undefined","children":"noteIdsByWeekTs"}],", ",["$","code",null,{"className":"$undefined","children":"noteIdsByDayTs"}],"."]}],"\n",["$","p",null,{"children":["Глобальный стейт решает 3 основный задачи - хранить, записывать и доставать данные. Чем удобнее, тем лучше.\nRedux предлагает редьюсеры, экшены и селекторы для этих задач.\nЕсли говорить про стандартную реализацию, ",["$","a",null,{"href":"https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers","rel":"nofollow","target":"_blank","children":"https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers"}],",\nто про про удобство говорить не приходится, switch case конструкция для экшенов - это боль.\nРазработчики редакса тоже так подумали и изобрели красивую обертку под названием ",["$","strong",null,{"children":"Redux Toolkit."}],"\nОднако они умудрились превратить ",["$","strong",null,{"children":"3.33 kB"}]," в ",["$","strong",null,{"children":"37 kB"}]," и это наталкивает на мысль, что они напихали слишком много лишнего.\nВозможно, им следовало бы остановиться на методе ",["$","code",null,{"className":"$undefined","children":"createSlice"}],",\nкоторый позволяет создавать редьюсер и экшены без лишней головной боли, а так же хуке useSlectors.\nИменно эти вещи я и хочу реализовать самостоятельно. Это будет интересно еще и точки зрения типизации."]}],"\n",["$","h2",null,{"id":"api","children":"API"}],"\n",["$","p",null,{"children":"Для начала нужно прикинуть, что именно мы хотим получить на выходе.\nВ рамках данной статьи я хочу реализовать метод createSlice, где можно было бы создать экшены и селекторы,\nа так же useSelector для доступа к данным из реакт компонента и dispatch для вызова экшенов"}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"usersSlice.ts","code":"$b","language":"ts","highlightedLines":[]}]}],"\n",["$","h2",null,{"id":"implementation","children":"Реализация"}],"\n",["$","p",null,{"children":["Для начала определимся с параметрами ",["$","code",null,{"className":"$undefined","children":"createSlice"}]," и набросаем небольшой черновик:"]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"type SliceActionCreator<State, Payload = any> = (\n  state: State,\n  payload: Payload\n) => void;\n\ntype SliceSelector<State, Payload = unknown, SelectorReturn = unknown> = (\n  state: State,\n  payload: Payload\n) => SelectorReturn;\n\ntype CreateSliceProps<\n  Name extends string,\n  State extends Record<string, unknown>,\n  Actions extends Record<string, SliceActionCreator<State>>,\n  Selectors extends Record<string, SliceSelector<State>>\n> = {\n  name: Name;\n  actions: Actions;\n  defaultState: State;\n  selectors: Selectors;\n};\n\nexport const createSlice = <\n  Name extends string,\n  State extends Record<string, unknown>,\n  Actions extends Record<string, SliceActionCreator<State>>,\n  Selectors extends Record<string, SliceSelector<State>>\n>({\n  name,\n  actions,\n  defaultState,\n  selectors,\n}: CreateSliceProps<Name, State, Actions, Selectors>) => {\n  let sliceActions; // TODO\n  let reducer; // TODO\n  let sliceSelectors; // TODO\n\n  return {\n    reducer,\n    selectors: sliceSelectors,\n    actions: sliceActions,\n  };\n};\n\n","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":"План такой - сначала реализовать экшены, потом редьюсер и в самом конце - селекторы."}],"\n",["$","h2",null,{"id":"actions","children":"Экшены"}],"\n",["$","p",null,{"children":["Экшен представляет из себя объект с обязательным полем ",["$","code",null,{"className":"$undefined","children":"type"}]," и опциональным ",["$","code",null,{"className":"$undefined","children":"payload"}]]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"type Action<Type extends string = string, Payload = unknown> = {\n  type: Type;\n  payload?: Payload;\n};\n","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":"Пусть, если в метод createSlice прокинуты"}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"const props = {\n  name: 'users',\n  actions: {\n    addUser: (state, user: User) => {\n      state.userById[user.id] = user;\n      state.usernameById[user.username] = user.id;\n    },\n    deleteUser: (state, userId: string) => {\n      const user = state.userById[userId];\n      delete state.usernameById[user.username];\n      delete state.userById[userId];\n    }\n  }\n}\n","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":"то мы будем генерировать два actionType:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"users/addUser"}],"\n",["$","li",null,{"children":"users/deleteUser"}],"\n"]}],"\n",["$","p",null,{"children":"и два экшена -"}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"const addUser = (user: User) => ({\n  type: \"users/addUser\",\n  payload: user,\n});\n\nconst deleteUser = (userId: string) => ({\n  type: \"users/deleteUser\",\n  payload: user,\n});\n","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":"Префикс с названием слайса добавлен для удобства и для того, чтобы предотвратить конфликт экшенов с одинаковыми названиями."}],"\n",["$","p",null,{"children":["Нам понадобится два новых типа - ",["$","code",null,{"className":"$undefined","children":"ActionKey"}]," и ",["$","code",null,{"className":"$undefined","children":"ActionType"}]]}],"\n",["$","p",null,{"children":[["$","code",null,{"className":"$undefined","children":"ActionKey"}]," - это ключи переданного объекта actions, а ",["$","code",null,{"className":"$undefined","children":"ActionType"}]," - это экшены, которые генерирует слайс, те же ключи, но с префиксом,"]}],"\n",["$","p",null,{"children":["Для создания типа ",["$","code",null,{"className":"$undefined","children":"ActionType"}]," используется небольшой генерик хелпер ",["$","code",null,{"className":"$undefined","children":"Scoped"}]]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"$c","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":"Остановлюсь на некоторых аспектах типизации чуть подробнее"}],"\n",["$","p",null,{"children":[["$","code",null,{"className":"$undefined","children":"ActionKey"}]," должен быть генериком, который будет на лету подхватывать ключи из переданного объекта ",["$","code",null,{"className":"$undefined","children":"Actions"}],".\nУ объекта в качестве ключа помимо строки может быть число или символ.\nЧтобы избежать проблем с типизацией, нужно достать только строки при помощи  ",["$","code",null,{"className":"$undefined","children":"Extract<keyof Actions, string>"}]]}],"\n",["$","p",null,{"children":["Чтобы сгенерировать экшены с правильным payload (чтобы у ",["$","code",null,{"className":"$undefined","children":"addUser"}]," была поддержка типизации и аргументом был именно ",["$","code",null,{"className":"$undefined","children":"user: User"}],"),\nнужно достать второй аргумент из переданного коллбека. Для этого воспользуемся хелпером ",["$","code",null,{"className":"$undefined","children":"Parameters"}],"\nи укажем нужный ",["$","code",null,{"className":"$undefined","children":"ActionKey"}],"-  ",["$","code",null,{"className":"$undefined","children":"Parameters<Actions[ActionType]>[1]"}]]}],"\n",["$","p",null,{"children":"Проверим, что все работает правильно:"}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"export const usersSlice = createSlice({\n  name: 'users',\n  defaultState: {\n    userById: {} as Record<string, User>,\n    usernameById: {} as Record<string, string>,\n  },\n  actions: {\n    addUser: (state, user: User) => {\n      // state должен иметь тот же тип, что и defaultState\n      state.userById[user.id] = user;\n      state.usernameById[user.username] = user.id;\n    },\n    deleteUser: (state, userId: string) => {\n      const user = state.userById[userId];\n      delete state.usernameById[user.username];\n      delete state.userById[userId];\n    }\n  },\n  selectors: {\n    selectUserByUsername: (state, username: string) => state.userById[state.usernameById[username]],\n  }\n});\n\nusersSlice.actions; // можно навести на actions и увидеть его тип\n","language":"ts","highlightedLines":[]}]}],"\n",["$","figure",null,{"className":"img-wrapper","children":[["$","$Ld",null,{"src":"/_next/static/media/actions-type-hightlight.ef33adb0.png","alt":"Подсказка в vs code","height":299,"width":702,"className":"rounded"}],["$","figcaption",null,{"className":"pt-2 text-body2 text-text-primary/70","children":"Подсказка в vs code"}]]}],"\n",["$","h2",null,{"id":"reducer","children":"Редьюсер"}],"\n",["$","p",null,{"children":["По своей сути редьюсер - это чистая функция, которая принимает два аргумента - ",["$","code",null,{"className":"$undefined","children":"state"}]," и ",["$","code",null,{"className":"$undefined","children":"action"}]," и возвращает ",["$","code",null,{"className":"$undefined","children":"nextState"}],".\nОчень важно при этом, чтобы стейт был иммутабельным, ради этого обычно используются страшные конструкции вроде"]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"const nextState = {\n\t...state,\n\tuserById: {\n\t\t...state.userById,\n\t\t[user.id]: user, \n\t}\n}\n","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":["Чтобы облегчить себе жизнь, для создания иммутабельного стейта предлагаю использовать\n",["$","a",null,{"href":"https://github.com/immerjs/immer","rel":"nofollow","target":"_blank","children":"https://www.npmjs.com/package/immer"}],", в частности метод\n",["$","a",null,{"href":"https://immerjs.github.io/immer/produce","rel":"nofollow","target":"_blank","children":"produce"}]]}],"\n",["$","p",null,{"children":["таким образом все, что нам нужно - это вызвать внутри ",["$","code",null,{"className":"$undefined","children":"produce"}]," нужный коллбек (экшен), передав туда драфт стейта и payload экшена"]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"const reducer = (state: State = defaultState, action: Action) => {\n  const nextState = produce(state, draft => {\n    actions[action.type]?.(draft as State, action.payload);\n  })\n  return nextState;\n}\n","language":"ts","highlightedLines":[]}]}],"\n",["$","h2",null,{"id":"selectors","children":"Селекторы"}],"\n",["$","p",null,{"children":["Для работы в связке с react + redux используется хук ",["$","code",null,{"className":"$undefined","children":"useSelector"}]," ."]}],"\n",["$","p",null,{"children":["Чтобы реакт знал и мог реагировать (делать ререндер компонента) на изменения в стейте существует метод\n",["$","a",null,{"href":"https://react.dev/reference/react/useSyncExternalStore","rel":"nofollow","target":"_blank","children":"useSyncExternalStore"}]]}],"\n",["$","p",null,{"children":"Например, чтобы получить актуальный стейт, можно написать следующий код:"}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"const useStore = () => {\n  const state = useSyncExternalStore(\n    myStore.subscribe,\n    myStore.getState,\n  );\n\n  return state;\n}\n","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":["Мы могли бы даже использовать селектор, чтобы достать из стора нужные нам данные,\nоднако такая реализация будет реагировать на ",["$","strong",null,{"children":"любые"}]," изменения в стейте."]}],"\n",["$","p",null,{"children":"Мы же хотим, чтобы наш useSelector реагировал только на изменения результата селектора, а не всего стейта.\nТ.е. чтобы селектор"}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"const username = useSelector(state => state.users.usersById['some-id'].username);\n","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":"реагировал только на изменение username конкретного юзера (с id = “some-id”)."}],"\n",["$","p",null,{"children":["Предлагаю не писать велосипед и использовать ",["$","code",null,{"className":"$undefined","children":"useSyncExternalStoreWithSelector"}],".\nЭто модифицированная версия ",["$","code",null,{"className":"$undefined","children":"useSyncExternalStore"}]," c поддержкой селекторов и мемоизацией."]}],"\n",["$","p",null,{"children":["Таким образом хелпер для создания ",["$","code",null,{"className":"$undefined","children":"useSelector"}]," будет выглядеть следующим образом:"]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"import type { Store as ReduxStore } from 'redux'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector';\n\nexport const createUseSelector = <\n  Store extends ReduxStore,\n  State extends ReturnType<Store['getState']>,\n>(store: Store) => {\n  const useSelector = <Selector extends (state: State) => unknown>(selector: Selector) => {\n    return useSyncExternalStoreWithSelector(\n      store.subscribe,\n      store.getState,\n      store.getState,\n      selector\n    ) as ReturnType<Selector>;\n  }\n\n  return useSelector;\n}\n","language":"ts","highlightedLines":[]}]}],"\n",["$","h2",null,{"id":"global-store","children":"Глобальный стор"}],"\n",["$","p",null,{"children":["В redux-toolkit есть метод ",["$","code",null,{"className":"$undefined","children":"configureStore"}]," для создания глобального стора.\nПредлагаю написать минималистичную версию, которая лишь объединяет редьюсеры и создает store"]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"$undefined","code":"$e","language":"ts","highlightedLines":[]}]}],"\n",["$","p",null,{"children":["Чтобы правильно типизировать созданный стор, нужно указать стейт и экшены редьюсера,\nкоторый будет создан при помощи ",["$","code",null,{"className":"$undefined","children":"combineReducers"}],".\nМы можем извлечь стейт и экшены из редьюсеров при помощи ",["$","code",null,{"className":"$undefined","children":"infer"}],".\nВ хелпере ",["$","code",null,{"className":"$undefined","children":"TypesFromSlices"}]," мы постепенно проверяем сначала, что ",["$","code",null,{"className":"$undefined","children":"T"}]," расширяет массив объектов,\nгде есть два интересующих нас поля - ",["$","code",null,{"className":"$undefined","children":"name"}]," и ",["$","code",null,{"className":"$undefined","children":"reducer"}],". Мы можем вытащить типы этих полей при помощи ",["$","code",null,{"className":"$undefined","children":"infer"}],".\nПохожим образом при помощи ",["$","code",null,{"className":"$undefined","children":"infer"}]," можно вытащить типы ",["$","code",null,{"className":"$undefined","children":"State"}]," и ",["$","code",null,{"className":"$undefined","children":"Action"}],".\nИз ",["$","code",null,{"className":"$undefined","children":"Action"}]," в свою очередь можно достать ",["$","code",null,{"className":"$undefined","children":"Type"}]," и ",["$","code",null,{"className":"$undefined","children":"Payload"}],".\nПосле этого мы можем вернуть извлеченные типы для ",["$","code",null,{"className":"$undefined","children":"action"}]," и ",["$","code",null,{"className":"$undefined","children":"state"}]]}],"\n",["$","h2",null,{"id":"bring-all-together","children":"Собираем все вместе"}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"myReduxToolkit.ts","code":"$f","language":"ts","highlightedLines":[]}]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"store/users/slice.ts","code":"import { createSlice } from \"@/myReduxToolkit\";\n\ntype User = {\n  id: string;\n  username: string;\n  displayName: string;\n}\n\nexport const usersSlice = createSlice({\n  name: 'users',\n  defaultState: {\n    userById: {} as Record<string, User>,\n    usernameById: {} as Record<string, string>,\n  },\n  actions: {\n    addUser: (state, user: User) => {\n      state.userById[user.id] = user;\n      state.usernameById[user.username] = user.id;\n    },\n    deleteUser: (state, userId: string) => {\n      const user = state.userById[userId];\n      delete state.usernameById[user.username];\n      delete state.userById[userId];\n    }\n  },\n  selectors: {\n    selectUserByUsername: (state, username: string) => state.userById[state.usernameById[username]],\n    selectAllUsers: (state) => Object.values(state.userById),\n  }\n});\n\n","language":"ts","highlightedLines":[]}]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"store/index.ts","code":"import { configureStore, createUseSelector } from '@/myReduxToolkit';\nimport { usersSlice } from './users/slice';\n\nexport const { store } = configureStore([usersSlice]);\n\nexport const useSelector = createUseSelector(store);\n\n","language":"ts","highlightedLines":[]}]}],"\n",["$","pre",null,{"children":["$","$La",null,{"caption":"components/SomeComponent.tsx","code":"const Test = () => {\n  const allUsers = useSelector(state => usersSlice.selectors.selectAllUsers(state.users));\n\n  console.log({\n    allUsers\n  })\n\n  return <div>\n    <button onClick={() => {\n      console.log(usersSlice.actions);\n      store.dispatch(usersSlice.actions.addUser({\n        displayName: String(Math.random()),\n        id: String(Math.random()),\n        username: String(Math.random()),\n      }));\n      console.log(store.getState())\n    }}>Add new user</button>\n\n    {allUsers.map((user) => <div key={user.username}>\n      <p>{user.displayName}</p>\n      <p>@{user.username}</p>\n    </div>)}\n  </div>\n}\n","language":"tsx","highlightedLines":[]}]}]]}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"http://schema.org/\",\"@type\":\"Article\",\"author\":{\"@type\":\"Person\",\"name\":\"Трофимов Евгений\"},\"headline\":\"Пишем свой redux-toolkit\",\"datePublished\":\"2024-02-12\"}"}}]]
10:["slug","implementing-own-redux-toolkit","d"]
3:["$","div",null,{"children":[["$","$L7",null,{"href":"/blog","className":"mb-8 block","children":"← Блог"}],["$","div",null,{"children":[["$","section",null,{"className":"overflow-hidden","children":["$","header",null,{"className":"py-8 border-t-[6px] border-b-2 dark:border-night md:mb-10","children":[["$","h1",null,{"className":"text-2xl font-primary block mb-4","children":"Пишем свой redux-toolkit"}],["$","h2",null,{"className":"font-primary text-md font-normal block mb-8 dark:text-beige text-gray-600","children":"Как работает @reduxjs/toolkit, реализация его упрощенной версии"}],["$","div",null,{"className":"flex gap-2 flex-wrap gap-y-1","children":[["$","$L7",null,{"className":"bg-gray-50/20 dark:bg-beige/5 rounded-3xl border-2 border-gray-50/50 dark:border-night px-3 py-[6px] text-gray-500 dark:text-beige inline-flex items-center text-body2","href":"/blog/topics/react","children":"React"}],["$","$L7",null,{"className":"bg-gray-50/20 dark:bg-beige/5 rounded-3xl border-2 border-gray-50/50 dark:border-night px-3 py-[6px] text-gray-500 dark:text-beige inline-flex items-center text-body2","href":"/blog/topics/redux","children":"Redux"}],["$","$L7",null,{"className":"bg-gray-50/20 dark:bg-beige/5 rounded-3xl border-2 border-gray-50/50 dark:border-night px-3 py-[6px] text-gray-500 dark:text-beige inline-flex items-center text-body2","href":"/blog/topics/typescript","children":"Typescript"}],["$","$L7",null,{"className":"bg-gray-50/20 dark:bg-beige/5 rounded-3xl border-2 border-gray-50/50 dark:border-night px-3 py-[6px] text-gray-500 dark:text-beige inline-flex items-center text-body2","href":"/blog/topics/state-manager","children":"State-manager"}]]}],["$","time",null,{"className":"text-body2 text-lilac block mt-4","children":"12 февраля 2024"}]]}]}],["$","div",null,{"className":"flex flex-col md:grid md:grid-cols-12 gap-5","children":[["$","div",null,{"className":"styles_blogContent__54hPI md:col-span-8","id":"content","children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$10","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e41f5598c8b4cc3e.css","precedence":"next","crossOrigin":""}]]}]}],["$","aside",null,{"className":"md:col-start-10 md:col-span-2 md:sticky top-4 self-start shrink-0 order-first md:order-last","children":["$","$L11",null,{"contentId":"content"}]}]]}]]}]]}]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Пишем свой redux-toolkit"}],["$","meta","3",{"name":"description","content":"Как работает @reduxjs/toolkit, реализация его упрощенной версии"}],["$","meta","4",{"property":"og:title","content":"Пишем свой redux-toolkit"}],["$","meta","5",{"property":"og:description","content":"Как работает @reduxjs/toolkit, реализация его упрощенной версии"}],["$","meta","6",{"property":"og:type","content":"article"}],["$","meta","7",{"property":"article:published_time","content":"2024-02-12"}],["$","meta","8",{"property":"article:author","content":"Трофимов Евгений"}],["$","meta","9",{"property":"article:tag","content":"react"}],["$","meta","10",{"property":"article:tag","content":"redux"}],["$","meta","11",{"property":"article:tag","content":"typescript"}],["$","meta","12",{"property":"article:tag","content":"state-manager"}],["$","meta","13",{"name":"twitter:card","content":"summary"}],["$","meta","14",{"name":"twitter:title","content":"Пишем свой redux-toolkit"}],["$","meta","15",{"name":"twitter:description","content":"Как работает @reduxjs/toolkit, реализация его упрощенной версии"}],["$","link","16",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","17",{"name":"next-size-adjust"}]]
1:null
